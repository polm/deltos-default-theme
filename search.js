;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by LiveScript 1.4.0
(function(){
  var WINDOW, philtre, map, loadEntriesThen, makeHitDiv, makeEmbed, search, searchHits, pointerHandler, input;
  WINDOW = 5;
  philtre = require('philtre').philtre;
  map = function(list, func){
    return Array.prototype.map.call(list, func);
  };
  loadEntriesThen = function(callback){
    var req;
    req = new XMLHttpRequest();
    req.onload = callback;
    req.open('GET', '/deltos.json', true);
    return req.send();
  };
  loadEntriesThen(function(it){
    var entries, input;
    entries = it.target.response.split("\n").filter(function(it){
      return it.length > 0;
    }).map(function(it){
      return JSON.parse(it);
    });
    window.entries = entries;
    input = document.querySelector('.deltos-search');
    input.oninput = search;
    return search();
  });
  makeHitDiv = function(entry){
    var div;
    div = document.createElement('div');
    div.innerHTML = makeEmbed(entry);
    return div;
  };
  makeEmbed = function(entry){
    var out, url;
    out = "<a class=\"result\" href=\"" + entry.link + "\">";
    out += '<div class="summary-small">';
    out += '<div class="imgwrapper" ';
    if (entry.image) {
      url = entry.image;
      if (/imgur.com/.test(entry.image)) {
        url = url.substr(0, url.length - 5) + 's.jpg';
      }
      out += "style=\"background-image: url(" + url + ")\"";
    }
    out += "></div>";
    out += "<h2>" + entry.title + "</h2>";
    out += "<p>" + entry.description + "</p>";
    return out += "</div></a>";
  };
  search = function(){
    var rd, input, summary, query, results, out, i$, len$, entry, results$ = [];
    rd = document.querySelector('.deltos-results');
    input = document.querySelector('.deltos-search');
    summary = document.querySelector('.deltos-results-summary');
    rd.innerHTML = '';
    query = input.value.toLowerCase();
    results = philtre(query, entries);
    input.hits = results.length;
    out = results.slice(input.offset, input.offset + WINDOW);
    summary.innerHTML = "Showing " + (input.offset + 1) + " to " + (input.offset + out.length) + " of " + results.length + " hits";
    for (i$ = 0, len$ = out.length; i$ < len$; ++i$) {
      entry = out[i$];
      results$.push(rd.appendChild(makeHitDiv(entry)));
    }
    return results$;
  };
  searchHits = function(entry, query){
    if (!query || query.length === 0) {
      return true;
    }
    return new RegExp(query, 'i').test(entry.searchableText);
  };
  pointerHandler = function(it){
    var results, event, reRender, ref$;
    results = document.querySelectorAll(".deltos-results .result");
    map(results, function(it){
      return it.classList.remove('selected');
    });
    event = it;
    reRender = function(){
      event.preventDefault();
      search();
      return results = document.querySelectorAll(".deltos-results .result");
    };
    switch (it.keyCode) {
    case 33:
    case 34:
      console.log(this);
      if (it.keyCode === 33) {
        this.offset = Math.max(0, this.offset - WINDOW);
      }
      if (it.keyCode === 34) {
        this.offset = Math.min(WINDOW * ~~(this.hits / WINDOW), this.offset + WINDOW);
      }
      reRender();
      break;
    case 38:
      if (this.pointer === 0 && this.offset > 0) {
        this.offset -= WINDOW;
        this.pointer = WINDOW;
        reRender();
      }
      this.pointer = Math.max(-1, this.pointer - 1);
      break;
    case 40:
      if (this.pointer + 1 === WINDOW && this.offset + WINDOW < this.hits) {
        this.offset += WINDOW;
        this.pointer = -1;
        reRender();
      }
      this.pointer = Math.min(WINDOW - 1, this.pointer + 1);
      break;
    case 13:
      if (this.pointer > -1 && this.pointer < results.length) {
        document.location = results[this.pointer].href;
      }
      break;
    default:
      'ok';
    }
    return (ref$ = results[this.pointer]) != null ? ref$.classList.add('selected') : void 8;
  };
  input = document.querySelector('.deltos-search');
  input.pointer = -1;
  input.offset = 0;
  input.hits = 0;
  input.onkeydown = pointerHandler;
  input.focus();
}).call(this);

},{"philtre":2}],2:[function(require,module,exports){
// Generated by LiveScript 1.4.0
(function(){
  var tagged, contains, has, checkField, before, after, getQuotedString, makeNot, makeOr, getParenString, getUntilCloser, philtreCore, philtre, out$ = typeof exports != 'undefined' && exports || this;
  tagged = curry$(function(tag, item){
    var ref$;
    return -1 < ((ref$ = item.tags) != null ? ref$.indexOf(tag) : void 8);
  });
  contains = curry$(function(string, item){
    var option, reg, key, ref$;
    option = 'i';
    if (string.match(/[A-Z]/)) {
      option = '';
    }
    reg = new RegExp(string, option);
    for (key in item) {
      if ((ref$ = item[key]) != null && (typeof ref$.toString == 'function' && ref$.toString().match(reg))) {
        return true;
      }
    }
    return false;
  });
  has = curry$(function(field, item){
    return item != null ? item[field] : void 8;
  });
  checkField = curry$(function(field, value, item){
    var ref$;
    return -1 < (item != null ? (ref$ = item[field]) != null ? ref$.toString().indexOf(value) : void 8 : void 8);
  });
  before = curry$(function(date, item){
    return item.date < date;
  });
  after = curry$(function(date, item){
    return item.date > date;
  });
  getQuotedString = function(str){
    var opener;
    opener = str[0];
    str = str.substr(1);
    return getUntilCloser(str, opener);
  };
  makeNot = function(f){
    return function(it){
      return !f(it);
    };
  };
  makeOr = function(a, b){
    return function(it){
      return a(it) || b(it);
    };
  };
  getParenString = function(str){
    str = str.substr(1);
    return getUntilCloser(str, ")");
  };
  getUntilCloser = function(str, closer){
    var out, char;
    out = '';
    while (str.length > 0) {
      char = str[0];
      str = str.substr(1);
      if (char === closer) {
        return [out, str];
      }
      if (char === "\\") {
        out += str[0];
        str = str.substr(1);
        continue;
      }
      out += char;
    }
  };
  philtreCore = function(query){
    var conds, ref$, word, key, value, ucw, condsOut, ii;
    conds = [];
    while (query.length > 0) {
      if (query[0] === "(") {
        ref$ = getParenString(query), word = ref$[0], query = ref$[1];
        conds.push(philtreCore(word));
        continue;
      }
      if (query[0] === "-") {
        conds.push("NOT");
        query = query.substr(1);
        continue;
      }
      if (query[0] === '#') {
        query = query.substr(1);
        if (-1 < query.indexOf(' ')) {
          word = query.substr(0, query.indexOf(' '));
        } else {
          word = query;
        }
        query = query.substr(1 + word.length);
        conds.push(tagged(word));
        continue;
      }
      if (query.match(/^[A-z]*:/)) {
        key = query.substr(0, query.indexOf(":"));
        query = query.substr(1 + query.indexOf(":"));
        if (query[0] === '"' || query[0] === '\'') {
          ref$ = getQuotedString(query), value = ref$[0], query = ref$[1];
        } else {
          if (-1 < query.indexOf(' ')) {
            value = query.substr(0, query.indexOf(' '));
          } else {
            value = query;
          }
          query = query.substr(1 + value.length);
        }
        conds.push((fn$()));
        continue;
      }
      if (query[0] === '"' || query[0] === '\'') {
        ref$ = getQuotedString(query), word = ref$[0], query = ref$[1];
      } else {
        if (-1 < query.indexOf(' ')) {
          word = query.substr(0, query.indexOf(' '));
        } else {
          word = query;
        }
        query = query.substr(1 + word.length);
      }
      ucw = word.toUpperCase();
      if (ucw === "AND") {
        continue;
      }
      if (ucw === "OR" || ucw === "NOT") {
        conds.push(ucw);
        continue;
      }
      if (word === '') {
        continue;
      }
      conds.push(contains(word));
      continue;
    }
    condsOut = [];
    ii = 0;
    while (ii < conds.length) {
      if (conds[ii + 1] === "OR") {
        condsOut.push(makeOr(conds[ii], conds[ii + 2]));
        ii += 3;
        continue;
      }
      if (conds[ii] === "NOT") {
        condsOut.push(makeNot(conds[ii + 1]));
        ii += 2;
        continue;
      }
      condsOut.push(conds[ii]);
      ii += 1;
    }
    return function(it){
      var i$, ref$, len$, f;
      for (i$ = 0, len$ = (ref$ = condsOut).length; i$ < len$; ++i$) {
        f = ref$[i$];
        if (!f(it)) {
          return false;
        }
      }
      return true;
    };
    function fn$(){
      switch (key) {
      case 'is':
      case 'has':
        return has(value);
      case 'before':
        return before(value);
      case 'after':
        return after(value);
      default:
        return checkField(key, value);
      }
    }
  };
  out$.philtre = philtre = curry$(function(query, items){
    var conds;
    query = query.trim();
    conds = philtreCore(query);
    return items.filter(conds);
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

},{}]},{},[1])
;